import inspect
import warnings
from enum import Enum

import logging, os
from datetime import timedelta
from functools import wraps
from hashlib import sha512
from typing import List, Union, Callable, Tuple, Dict

from viur.core import tasks, utils, db, current
from viur.core.config import conf

"""
    This module implements a cache that can be used to serve entire requests or cache the output of any function
    (as long it's result can be stored in datastore). The intended use is to wrap functions that can be called from
    the outside (@exposed) with the @enableCache decorator. This will enable the cache provided in this module for that
    function, intercepting all calls to this function and serve a cached response instead of calling the function if
    possible. Authenticated users with "root" access can always bypass this cache by sending the X-Viur-Disable-Cache
    http Header    along with their requests. Entities in this cache will expire if
        - Their TTL is exceeded
        - They're explicitly removed from the cache by calling :meth:`viur.core.cache.flushCache` using their path
        - A Datastore entity that has been accessed using db.Get() from within the cached function has been modified
        - The wrapped function has run a query over a kind in which an entity has been added/edited/deleted

    ..Warning: As this cache is intended to be used with exposed functions, it will not only store the result of the
        wrapped function, but will also store and restore the Content-Type http header. This can cause unexpected
        behaviour if it's used to cache the result of non top-level functions, as calls to these functions now may
        cause this header to be rewritten.
"""

viurCacheName = "viur-cache"

class CacheState(Enum):
    """
    An enumeration representing the different consistency strategies for handling stale relations in
    the RelationalBone class.
    """
    """Regardless of whether the user is known or a guest, the same content is always delivered"""
    Independent = 0
    """The cache is only delivered for guests"""
    GuestsOnly = 1
    """The cache is divided into 2 groups one for users and one for guests"""
    GuestOrUser = 2
    """The result is saved separately for each individual user."""
    AllSeparate = 3


def key_from_args(f: Callable, user_sensitive: CacheState, language_sensitive: bool, evaluated_args: List[str], path: str,
                args: Tuple, kwargs: Dict) -> str:
    """
        Utility function to derive a unique but stable string-key that can be used in a datastore-key
        for the given wrapped function f, the parameter *args and **kwargs it has been called with,
        the path-components from the url that point to the outer @exposed function which handles this request
        as well as the configuration (user_sensitive, language_sensitive and evaluated_args) provided to the @enableCache
        decorator. To derive the key, we'll first map all positional arguments to their keyword equivalent, construct
        a dict with the parameters having an effect on the result, merge the context variables (language, session state)
        in, sort this dict by key, cast it to string and return it's sha512 hash.

        :param f: Callable which is inspected for its signature
            (we need to figure out what positional arguments map to which key argument)
        :param user_sensitive: Signals wherever the output of f depends on the current user.
            0 means independent of wherever the user is a guest or known, all will get the same content.
            1 means cache only for guests, no cache will be performed if the user is logged-in.
            2 means cache in two groups, one for guests and one for all users
            3 will cache the result of that function for each individual users separately.
        :param evaluated_args: List of keyword-arguments having influence to the output generated by
            that function. This list *must* complete! Parameters not named here are ignored!
        :param path: Path to the function called but without parameters (ie. "/page/view")
        :returns: The unique key derived
    """
    fn_args= inspect.getfullargspec(f).args[1:]
    # Map default values in
    res = {
        k: v.default
        for k, v in inspect.signature(f).parameters.items()
        if v.default is not inspect.Parameter.empty
    }

    # Map args in
    set_args = set()  # Store a list of args already set by *args
    for idx in range(0, min(len(args), len(fn_args))):
        if fn_args[idx] in evaluated_args:
            set_args.add(fn_args[idx])
            res[fn_args[idx]] = args[idx]

    # Last, we map the kwargs in
    for k, v in kwargs.items():
        if k in evaluated_args:
            if k in set_args:
                raise AssertionError("Got dupplicate arguments for %s" % k)
            res[k] = v
    user = current.user.get()

    if not user_sensitive == CacheState.Independent:
        if user_sensitive == CacheState.GuestsOnly and user:  # We don't cache requests for each user separately
            return None
        elif user_sensitive == CacheState.GuestOrUser:
            if user:
                res["__user"] = "__ISUSER"
            else:
                res["__user"] = None
        elif user_sensitive == CacheState.AllSeparate:
            if user:
                res["__user"] = user["key"]
            else:
                res["__user"] = None
    if language_sensitive:
        res["__lang"] = current.language.get()
    if conf.cache_environment_key:
        try:
            res["_cacheEnvironment"] = conf.cache_environment_key()
        except RuntimeError:
            return None
    res["__path"] = path  # Different path might have different output (html,xml,..)
    try:
        app_version = conf.instance.app_version
    except:
        logging.error("Could not determine the current application version! Caching might produce unexpected results!")
        app_version = ""
    res["__appVersion"] = app_version
    # Last check, that every parameter is satisfied:
    if not all([x in res.keys() for x in fn_args]):
        # we have too few parameters for this function; that wont work
        return None
    res = list(res.items())  # flatten our dict to a list
    res.sort(key=lambda x: x[0])  # sort by keys
    mysha512 = sha512()
    mysha512.update(str(res).encode("UTF8"))
    return mysha512.hexdigest()


def wrap_callable(f, urls: List[str], user_sensitive: CacheState, language_sensitive: bool,
                  evaluated_args: List[str], lifetime: timedelta | None = None):
    """
        Does the actual work of wrapping a callable.
        Use the decorator enableCache instead of calling this directly.
    """

    @wraps(f)
    def wrapF(self, *args, **kwargs) -> Union[str, bytes]:
        current_request = current.request.get()
        if conf.debug.disable_cache or current_request.disableCache:
            # Caching disabled
            if conf.debug.disable_cache:
                logging.warning("Caching is disabled by config")
            return f(self, *args, **kwargs)
        # How many arguments are part of the way to the function called (and how many are just *args)
        print(f"{-len(current_request.args)= }")
        print(f"{len(current_request.path_list)= }")

        offset = -len(current_request.args) or len(current_request.path_list)

        print(f"{offset= }")
        path = "/" + "/".join(current_request.path_list[: offset])
        print(f"{current_request.path_list[: offset]=}")
        print(f"{path=}")
        if not path in urls:
            # This path (possibly a sub-render) should not be cached
            logging.debug("Not caching for %s" % path)
            return f(self, *args, **kwargs)
        key = key_from_args(f, user_sensitive, language_sensitive, evaluated_args, path, args, kwargs)
        if not key:
            # Something is wrong (possibly the parameter-count)
            # Let's call f, but we knew already that this will clash
            return f(self, *args, **kwargs)

        if cached_obj := db.Get(db.Key(viurCacheName, key)):
            if not lifetime or cached_obj["creationtime"] > utils.utcNow() - lifetime:
                # We store it unlimited or the cache is fresh enough
                logging.debug("This request was served from cache.")
                current_request.response.headers['Content-Type'] = cached_obj["content-type"]
                return cached_obj["data"]
        # If we made it this far, the request wasn't cached or too old; we need to rebuild it
        oldAccessLog = db.startDataAccessLog()
        try:
            res = f(self, *args, **kwargs)
        finally:
            accessed_entries = db.endDataAccessLog(oldAccessLog)
        cache_obj = db.Entity(db.Key(viurCacheName, key))
        cache_obj["data"] = res
        cache_obj["creationtime"] = utils.utcNow()
        cache_obj["path"] = path
        cache_obj["content-type"] = current_request.response.headers['Content-Type']
        cache_obj["accessedEntries"] = list(accessed_entries)
        cache_obj.exclude_from_indexes = ["data", "content-type"]  # We can save 2 DB-Writs :)
        db.Put(cache_obj)
        logging.debug("This request was a cache-miss. Cache has been updated.")
        return res

    return wrapF


def enableCache(urls: List[str], user_sensitive: CacheState = CacheState.Independent, language_sensitive: bool = False,
                evaluated_args: List[str] | None = None, lifetime: timedelta | None = None, **kwargs):
    """
        Decorator to wrap this cache around a function. In order for this to function correctly, you must provide
        additional information so ViUR can determine in which situations it's possible to re-use an already cached
        result and when to call the wrapped function instead.

        ..Warning: It's not possible to cache the result of a function relying on reading/modifying
            the environment (ie. setting custom http-headers). The only exception is the content-type header which
            will be stored along with the cached response.

        :param urls: A list of urls for this function, for which the cache should be enabled.
            A function can have several urls (eg. /page/view or /pdf/page/view), and it
            might should not be cached under all urls (eg. /admin/page/view).
        :param user_sensitive: Signals wherever the output of f depends on the current user.
            0 means independent of wherever the user is a guest or known, all will get the same content.
            1 means cache only for guests, no cache will be performed if the user is logged-in.
            2 means cache in two groups, one for guests and one for all users
            3 will cache the result of that function for each individual users separately.
        :param language_sensitive: If true, signals that the output of f might got translated.
            If true, the result of that function is cached separately for each language.
        :param evaluated_args: List of keyword-arguments having influence to the output generated by
            that function. This list *must* be complete! Parameters not named here are ignored!
            Warning: Double-check this list! F.e. if that function generates a list of entries and
            you miss the parameter "order" here, it would be impossible to sort the list.
            It would always have the ordering it had when the cache-entry was created.
        :param lifetime: Specifies the maximum time an entry stays in the cache in seconds.
            Note: Its not erased from the db after that time, but it won't be served anymore.
            If None, the cache stays valid forever (until manually erased by calling flushCache.
    """
    if "userSensitive" in kwargs:
        msg = f"""parameter userSensitive={kwargs["userSensitive"]} in enableCache is deprecated. """ \
              f"""Please use the CacheState enum and "user_sensitive" instead"""
        logging.warning(msg, stacklevel=3)
        warnings.warn(msg, DeprecationWarning, stacklevel=3)

        assert 0 <= kwargs["userSensitive"] < 4
        for n in CacheState:
            if kwargs["userSensitive"] == n.value:
                user_sensitive = n
    if "languageSensitive" in kwargs:
        msg = f"""parameter languageSensitive={kwargs["languageSensitive"]} in enableCache is deprecated. """ \
              f"""Please use "language_sensitive" instead"""
        logging.warning(msg, stacklevel=3)
        warnings.warn(msg, DeprecationWarning, stacklevel=3)

        language_sensitive = kwargs["languageSensitive"]
    if "evaluated_args" in kwargs:
        msg = f"""parameter evaluatedArgs={kwargs["evaluatedArgs"]} in enableCache is deprecated. """ \
              f"""Please use "evaluated_args" instead"""
        logging.warning(msg, stacklevel=3)
        warnings.warn(msg, DeprecationWarning, stacklevel=3)
        evaluated_args = kwargs["evaluatedArgs"]

    if "maxCacheTime" in kwargs:
        msg = f"""parameter maxCacheTime={kwargs["maxCacheTime"]} in enableCache is deprecated. """ \
              f"""Please use "lifetime" instead"""
        logging.warning(msg, stacklevel=3)
        warnings.warn(msg, DeprecationWarning, stacklevel=3)
        lifetime = kwargs["maxCacheTime"]

    if evaluated_args is None:
        evaluated_args = []

    assert not any([x.startswith("_") for x in evaluated_args]), "A evaluated Parameter cannot start with an underscore!"
    return lambda f: wrap_callable(f, urls, user_sensitive, language_sensitive, evaluated_args, lifetime)


@tasks.CallDeferred
def flushCache(prefix: str = None, key: Union[db.Key, None] = None, kind: Union[str, None] = None):
    """
        Flushes the cache. Its possible the flush only a part of the cache by specifying
        the path-prefix. The path is equal to the url that caused it to be cached (eg /page/view) and must be one
        listed in the 'url' param of :meth:`viur.core.cache.enableCache`.

        :param prefix: Path or prefix that should be flushed.
        :param key: Flush all cache entries which may contain this key. Also flushes entries
            which executed a query over that kind.
        :param kind: Flush all cache entries which executed a query over that kind.

        Examples:
            - "/" would flush the main page (and only that),
            - "/*" everything from the cache, "/page/*" everything from the page-module (default render),
            - and "/page/view/*" only that specific subset of the page-module.
    """
    if prefix is None and key is None and kind is None:
        prefix = "/*"
    if prefix is not None:
        items = db.Query(viurCacheName).filter("path =", prefix.rstrip("*")).iter()
        for item in items:
            db.Delete(item)
        if prefix.endswith("*"):
            items = db.Query(viurCacheName) \
                .filter("path >", prefix.rstrip("*")) \
                .filter("path <", prefix.rstrip("*") + u"\ufffd") \
                .iter()
            for item in items:
                db.Delete(item)
        logging.debug("Flushing cache succeeded. Everything matching \"%s\" is gone." % prefix)
    if key is not None:
        items = db.Query(viurCacheName).filter("accessedEntries =", key).iter()
        for item in items:
            logging.info("Deleted cache entry %s", item["path"])
            db.Delete(item.key)
        if not isinstance(key, db.Key):
            key = db.Key.from_legacy_urlsafe(key)  # hopefully is a string
        items = db.Query(viurCacheName).filter("accessedEntries =", key.kind).iter()
        for item in items:
            logging.info("Deleted cache entry %s", item["path"])
            db.Delete(item.key)
    if kind is not None:
        items = db.Query(viurCacheName).filter("accessedEntries =", kind).iter()
        for item in items:
            logging.info("Deleted cache entry %s", item["path"])
            db.Delete(item.key)


__all__ = ["enableCache", "flushCache"]
