:mod:`core.email`
=================

.. py:module:: core.email


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   core.email.EmailTransport
   core.email.DeleteOldEmailsFromLog
   core.email.EmailTransportSendInBlue



Functions
~~~~~~~~~

.. autoapisummary::

   core.email.cleanOldEmailsFromLog
   core.email.sendEmailDeferred
   core.email.normalizeToList
   core.email.sendEMail
   core.email.sendEMailToAdmins


.. function:: cleanOldEmailsFromLog(*args, **kwargs)

   Start the QueryIter DeleteOldEmailsFromLog to remove old, successfully send emails from the queue


.. class:: EmailTransport

   Bases: :class:`abc.ABC`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. attribute:: maxRetries
      :annotation: = 3

      

   .. method:: deliverEmail(*, sender: str, dests: List[str], cc: List[str], bcc: List[str], subject: str, body: str, headers: Dict[(str, str)], attachments: List[Dict[str, bytes]], customData: Union[(dict, None)], **kwargs)
      :staticmethod:
      :abstractmethod:

      The actual email delivery must be implemented here. All email-adresses can be either in the form of
      "mm@example.com" or "Max Musterman <mm@example.com>". If the delivery was successful, this method
      should return normally, if there was an error delivering the message it *must* raise an exception.

      :param sender: The sender to be used on the outgoing email
      :param dests: List of recipients
      :param cc: : List of carbon copy-recipients
      :param bcc: List of blind carbon copy-recipients
      :param subject: The subject of this email
      :param body: The contents of this email (may be text/plain or text/html)
      :param headers: Custom headers to send along with this email
      :param attachments: List of attachments to include in this email
      :param customData:


   .. method:: validateQueueEntity(entity: viur.core.db.Entity)
      :staticmethod:

      This function can be used to pre-validate the queue entity before it's deferred into the queue.
      Must raise an exception if the email cannot be send (f.e. if it contains an invalid attachment)
      :param entity: The entity to validate


   .. method:: transportSuccessfulCallback(entity: viur.core.db.Entity)
      :staticmethod:

      This callback can be overridden by the project to execute additional tasks after an email
      has been successfully send.
      :param entity: The entity which has been send



.. class:: DeleteOldEmailsFromLog

   Bases: :class:`viur.core.tasks.QueryIter`

   Simple Query-Iter to delete all entities encountered

   .. method:: handleEntry(cls, entry, customData)
      :classmethod:



.. function:: sendEmailDeferred(emailKey: viur.core.db.KeyClass)

   Callback from the Taskqueue to send the given Email
   :param emailKey: Database-Key of the email we should send


.. function:: normalizeToList(value: Union[(None, Any, List[Any])]) -> List[Any]

   Convert the given value to a list.


.. function:: sendEMail(*, tpl: str = None, stringTemplate: str = None, skel: Union[(None, Dict, 'SkeletonInstance', List['SkeletonInstance'])] = None, sender: str = None, dests: Union[(str, List[str])] = None, cc: Union[(str, List[str])] = None, bcc: Union[(str, List[str])] = None, headers: Dict[(str, str)] = None, attachments: List[Dict[str, Any]] = None, context: Union[(db.DATASTORE_BASE_TYPES, List[db.DATASTORE_BASE_TYPES], db.Entity)] = None, **kwargs) -> Any

   General purpose function for sending e-mail.
   This function allows for sending e-mails, also with generated content using the Jinja2 template engine.
   Your have to implement a method which should be called to send the prepared email finally. For this you have
   to allocate *viur.email.transportClass* in conf.

   :param tpl: The name of a template from the deploy/emails directory.
   :param stringTemplate: This string is interpreted as the template contents. Alternative to load from template file.
           :param skel: The data made available to the template. In case of a Skeleton or SkelList, its parsed the usual way;              Dictionaries are passed unchanged.
   :param sender: The address sending this mail.
   :param dests: A list of addresses to send this mail to. A bare string will be treated as a list with 1 address.
   :param cc: Carbon-copy recipients. A bare string will be treated as a list with 1 address.
   :param bcc: Blind carbon-copy recipients. A bare string will be treated as a list with 1 address.
   :param headers: Specify headers for this email.
   :param attachments: List of files to be sent within the mail as attachments. Each attachment must be a dictionary
           with these keys:
                   filename (string): Name of the file that's attached. Always required
                   content (bytes): Content of the attachment as bytes. Required for the send in blue API.
                   mimetype (string): Mimetype of the file. Suggested parameter for other implementations (not used by SIB)
                   gcsfile (string): Link to a GCS-File to include instead of content. Not supported by the current
                           SIB implementation
   :param context: Arbitrary data that can be stored along the queue entry to be evaluated in
           transportSuccessfulCallback (useful for tracking delivery / opening events etc).

   .. Warning:  As emails will be queued (and not send directly) you cannot exceed 1MB in total
                           (for all text and attachments combined)!


.. function:: sendEMailToAdmins(subject: str, body: str, *args, **kwargs)

   Sends an e-mail to the root users of the current app.

   :param subject: Defines the subject of the message.
   :param body: Defines the message body.


.. class:: EmailTransportSendInBlue

   Bases: :class:`core.email.EmailTransport`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. attribute:: maxRetries
      :annotation: = 3

      

   .. attribute:: allowedExtensions
      

      

   .. method:: splitAddress(address: str) -> Dict[(str, str)]
      :staticmethod:

      Splits an Name/Address Pair as "Max Musterman <mm@example.com>" into a dict
      {"name": "Max Mustermann", "email": "mm@example.com"}
      :param address: Name/Address pair
      :return: Splitted dict


   .. method:: deliverEmail(*, sender: str, dests: List[str], cc: List[str], bcc: List[str], subject: str, body: str, headers: Dict[(str, str)], attachments: List[Dict[str, bytes]], **kwargs)
      :staticmethod:

      Internal function for delivering Emails using Send in Blue. This function requires the
      conf["viur.email.sendInBlue.apiKey"] to be set.
      This function is supposed to return on success and throw an exception otherwise.
      If no exception is thrown, the email is considered send and will not be retried.


   .. method:: validateQueueEntity(entity: viur.core.db.Entity)
      :staticmethod:

      For Send in Blue, we'll validate the attachments (if any) against the list of supported file extensions



