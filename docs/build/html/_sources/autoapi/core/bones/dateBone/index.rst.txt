:mod:`core.bones.dateBone`
==========================

.. py:module:: core.bones.dateBone


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   core.bones.dateBone.dateBone



Functions
~~~~~~~~~

.. autoapisummary::

   core.bones.dateBone.datetimeToTimestamp


.. data:: pytz
   

   

.. function:: datetimeToTimestamp(datetimeObj: datetime.datetime) -> int

   Converts this DateTime-Object back into Unixtime


.. class:: dateBone(creationMagic=False, updateMagic=False, date=True, time=True, localize=False, *args, **kwargs)


   Bases: :class:`viur.core.bones.baseBone`

   .. attribute:: type
      :annotation: = date

      

   .. method:: generageSearchWidget(target, name='DATE BONE', mode='range')
      :staticmethod:


   .. method:: singleValueFromClient(self, value, skel, name, origData)

      Reads a value from the client.
      If this value is valid for this bone,
      store this value and return None.
      Otherwise our previous value is
      left unchanged and an error-message
      is returned.

      :param name: Our name in the skeleton
      :type name: str
      :param data: *User-supplied* request-data
      :type data: dict
      :returns: str or None


   .. method:: isInvalid(self, value)

      Ensure that year is >= 1900
      Otherwise strftime will break later on.


   .. method:: guessTimeZone(self)

      Guess the timezone the user is supposed to be in.
      If it cant be guessed, a safe default (UTC) is used


   .. method:: singleValueSerialize(self, value, skel: SkeletonInstance, name: str, parentIndexed: bool)


   .. method:: singleValueUnserialize(self, value, skel: viur.core.skeleton.SkeletonInstance, name: str)


   .. method:: buildDBFilter(self, name, skel, dbFilter, rawFilter, prefix=None)


   .. method:: performMagic(self, valuesCache, name, isAdd)



