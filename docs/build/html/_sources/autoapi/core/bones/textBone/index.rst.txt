:mod:`core.bones.textBone`
==========================

.. py:module:: core.bones.textBone


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   core.bones.textBone.HtmlSerializer
   core.bones.textBone.textBone



.. data:: _defaultTags
   

   

.. class:: HtmlSerializer(validHtml=None)


   Bases: :class:`html.parser.HTMLParser`

   Find tags and other markup and call handler functions.

   Usage:
       p = HTMLParser()
       p.feed(data)
       ...
       p.close()

   Start tags are handled by calling self.handle_starttag() or
   self.handle_startendtag(); end tags by self.handle_endtag().  The
   data between tags is passed from the parser to the derived class
   by calling self.handle_data() with the data as argument (the data
   may be split up in arbitrary chunks).  If convert_charrefs is
   True the character references are converted automatically to the
   corresponding Unicode character (and self.handle_data() is no
   longer split in chunks), otherwise they are passed by calling
   self.handle_entityref() or self.handle_charref() with the string
   containing respectively the named or numeric reference as the
   argument.

   .. method:: handle_data(self, data)


   .. method:: handle_charref(self, name)


   .. method:: handle_entityref(self, name)


   .. method:: flushCache(self)

      Flush pending tags into the result and push their corresponding end-tags onto the stack


   .. method:: handle_starttag(self, tag, attrs)

      Delete all tags except for legal ones 


   .. method:: handle_endtag(self, tag)


   .. method:: cleanup(self)

      Append missing closing tags 


   .. method:: sanitize(self, instr)



.. class:: textBone(validHtml: Union[(None, Dict)] = __undefinedC__, languages: Union[(None, List[str])] = None, maxLength: int = 200000, defaultValue: Any = None, indexed: bool = False, *args, **kwargs)


   Bases: :class:`viur.core.bones.baseBone`

   .. class:: __undefinedC__


   .. attribute:: type
      :annotation: = text

      

   .. method:: generageSearchWidget(target, name='TEXT BONE', mode='equals')
      :staticmethod:


   .. method:: singleValueSerialize(self, value, skel: SkeletonInstance, name: str, parentIndexed: bool)


   .. method:: singleValueFromClient(self, value, skel, name, origData)


   .. method:: getEmptyValue(self)


   .. method:: isInvalid(self, value)

      Returns None if the value would be valid for
      this bone, an error-message otherwise.


   .. method:: getReferencedBlobs(self, valuesCache, name)

      Test for /file/download/ links inside our text body.
      Doesn't check for actual <a href=> or <img src=> yet.


   .. method:: getSearchTags(self, skeltonValues, name)


   .. method:: getSearchDocumentFields(self, valuesCache, name, prefix='')

      Returns a list of search-fields (GAE search API) for this bone.


   .. method:: getUniquePropertyIndexValues(self, valuesCache: dict, name: str) -> List[str]



