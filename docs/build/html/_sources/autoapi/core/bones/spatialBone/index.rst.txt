:mod:`core.bones.spatialBone`
=============================

.. py:module:: core.bones.spatialBone


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   core.bones.spatialBone.spatialBone



Functions
~~~~~~~~~

.. autoapisummary::

   core.bones.spatialBone.haversine


.. function:: haversine(lat1, lng1, lat2, lng2)

   Calculates the distance between two points on Earth given by (lat1,lng1) and (lat2, lng2) in Meter.
   See https://en.wikipedia.org/wiki/Haversine_formula

   :return: Distance in Meter


.. class:: spatialBone(boundsLat, boundsLng, gridDimensions, *args, **kwargs)


   Bases: :class:`viur.core.bones.baseBone`

   Allows to query by Elements close to a given position.
   Prior to use, you must specify for which region of the map the index should be build.
   This region should be as small as possible for best accuracy. You cannot use the whole world, as
   no boundary wraps are been performed.
   GridDimensions specifies into how many sub-regions the map will be split. Results further away than the
   size of these sub-regions won't be considered within a search by this algorithm.

   Example:
           If you use this bone to query your data for the nearest pubs, you might want to this algorithm
           to consider results up to 100km distance, but not results that are 500km away.
           Setting the size of these sub-regions to roughly 100km width/height allows this algorithm
           to exclude results further than 200km away on database-query-level, therefore drastically
           improving performance and reducing costs per query.

   Example region: Germany: boundsLat=(46.988, 55.022), boundsLng=(4.997, 15.148)

   .. attribute:: type
      :annotation: = spatial

      

   .. method:: getGridSize(self)

      :return: the size of our sub-regions in (fractions-of-latitude, fractions-of-longitude)
      :rtype: (float, float)


   .. method:: isInvalid(self, value)

      Tests, if the point given by 'value' is inside our boundaries.
      We'll reject all values outside that region.
      :param value: (latitude, longitude) of the location of this entry.
      :type value: (float, float)
      :return: An error-description or False if the value is valid
      :rtype: str | False


   .. method:: singleValueSerialize(self, value, skel: SkeletonInstance, name: str, parentIndexed: bool)


   .. method:: singleValueUnserialize(self, val, skel: viur.core.skeleton.SkeletonInstance, name: str)


   .. method:: parseSubfieldsFromClient(self)


   .. method:: isEmpty(self, rawValue: Any)


   .. method:: getEmptyValue(self) -> Tuple[float]

      If you need a special marker for empty, use 91.0, 181.0.
      These are both out of range for Latitude (-90, +90) and Longitude (-180, 180) but will be accepted
      by Vi and Admin


   .. method:: singleValueFromClient(self, value, skel, name, origData)

      Reads a value from the client.
      If this value is valid for this bone,
      store this value and return None.
      Otherwise our previous value is
      left unchanged and an error-message
      is returned.
      :param name: Our name in the skeleton
      :type name: str
      :param data: *User-supplied* request-data
      :type data: dict
      :returns: None or String


   .. method:: buildDBFilter(self, name, skel, dbFilter, rawFilter, prefix=None)

      Parses the searchfilter a client specified in his Request into
      something understood by the datastore.
      This function must:

              * Ignore all filters not targeting this bone
              * Safely handle malformed data in rawFilter
                      (this parameter is directly controlled by the client)

      For detailed information, how this geo-spatial search works, see the ViUR documentation.

      :param name: The property-name this bone has in its Skeleton (not the description!)
      :type name: str
      :param skel: The :class:`server.db.Query` this bone is part of
      :type skel: :class:`server.skeleton.Skeleton`
      :param dbFilter: The current :class:`server.db.Query` instance the filters should be applied to
      :type dbFilter: :class:`server.db.Query`
      :param rawFilter: The dictionary of filters the client wants to have applied
      :type rawFilter: dict
      :returns: The modified :class:`server.db.Query`


   .. method:: calculateInternalMultiQueryLimit(self, dbQuery, targetAmount)

      Tells :class:`server.db.Query` How much entries should be fetched in each subquery.

      :param targetAmount: How many entries shall be returned from db.Query
      :type targetAmount: int
      :returns: The amount of elements db.Query should fetch on each subquery
      :rtype: int


   .. method:: customMultiQueryMerge(self, name, lat, lng, dbFilter, result, targetAmount)

      Randomly returns 'targetAmount' elements from 'result'

      :param dbFilter: The db.Query calling this function
      :type: dbFilter: server.db.Query
      :param result: The list of results for each subquery we've run
      :type result: list of list of :class:`server.db.Entity`
      :param targetAmount: How many results should be returned from db.Query
      :type targetAmount: int
      :return: List of elements which should be returned from db.Query
      :rtype: list of :class:`server.db.Entity`


   .. method:: setBoneValue(self, valuesCache, boneName, value, append, *args, **kwargs)

      Set our value to 'value'.
      Santy-Checks are performed; if the value is invalid, we flip our value back to its original
      (default) value and return false.

      :param valuesCache: Dictionary with the current values from the skeleton we belong to
      :type valuesCache: dict
      :param boneName: The Bone which should be modified
      :type boneName: str
      :param value: The value that should be assigned. It's type depends on the type of that bone
      :type boneName: object
      :param append: If true, the given value is appended to the values of that bone instead of
              replacing it. Only supported on bones with multiple=True
      :type append: bool
      :return: Wherever that operation succeeded or not.
      :rtype: bool



