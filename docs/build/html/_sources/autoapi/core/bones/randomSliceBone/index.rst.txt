:mod:`core.bones.randomSliceBone`
=================================

.. py:module:: core.bones.randomSliceBone


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   core.bones.randomSliceBone.randomSliceBone



.. class:: randomSliceBone(visible=False, readOnly=True, slices=2, sliceSize=0.5, *args, **kwargs)


   Bases: :class:`viur.core.bones.baseBone`

   Simulates the orderby=random from SQL.
   If you sort by this bone, the query will return a random set of elements from that query.

   .. attribute:: type
      :annotation: = randomslice

      

   .. method:: serialize(self, skel: SkeletonInstance, name: str, parentIndexed: bool) -> bool

      Serializes this bone into something we
      can write into the datastore.

      This time, we just ignore whatever is set on this bone and write a randomly chosen
      float [0..1) as value for this bone.

      :param name: The property-name this bone has in its Skeleton (not the description!)
      :type name: str
      :returns: dict


   .. method:: buildDBSort(self, name, skel, dbFilter, rawFilter)

      Same as buildDBFilter, but this time its not about filtering
      the results, but by sorting them.
      Again: rawFilter is controlled by the client, so you *must* expect and safely handle
      malformed data!

      This function is somewhat special as it doesn't just change in which order the selected
      Elements are being returned - but also changes *which* Elements are beeing returned (=>
      a random selection)

      :param name: The property-name this bone has in its Skeleton (not the description!)
      :type name: str
      :param skel: The :class:`server.skeleton.Skeleton` instance this bone is part of
      :type skel: :class:`server.skeleton.Skeleton`
      :param dbFilter: The current :class:`server.db.Query` instance the filters should be applied to
      :type dbFilter: :class:`server.db.Query`
      :param rawFilter: The dictionary of filters the client wants to have applied
      :type rawFilter: dict
      :returns: The modified :class:`server.db.Query`


   .. method:: calculateInternalMultiQueryLimit(self, targetAmount)

      Tells :class:`server.db.Query` How much entries should be fetched in each subquery.

      :param targetAmount: How many entries shall be returned from db.Query
      :type targetAmount: int
      :returns: The amount of elements db.Query should fetch on each subquery
      :rtype: int


   .. method:: customMultiQueryMerge(self, dbFilter, result, targetAmount)

      Randomly returns 'targetAmount' elements from 'result'

      :param dbFilter: The db.Query calling this function
      :type: dbFilter: server.db.Query
      :param result: The list of results for each subquery we've run
      :type result: list of list of :class:`server.db.Entity`
      :param targetAmount: How many results should be returned from db.Query
      :type targetAmount: int
      :return: list of elements which should be returned from db.Query
      :rtype: list of :class:`server.db.Entity`



