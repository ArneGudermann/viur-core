:mod:`core.bones.bone`
======================

.. py:module:: core.bones.bone


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   core.bones.bone.ReadFromClientErrorSeverity
   core.bones.bone.ReadFromClientError
   core.bones.bone.UniqueLockMethod
   core.bones.bone.UniqueValue
   core.bones.bone.MultipleConstraints
   core.bones.bone.baseBone



Functions
~~~~~~~~~

.. autoapisummary::

   core.bones.bone.setSystemInitialized
   core.bones.bone.getSystemInitialized


.. data:: __systemIsIntitialized_
   :annotation: = False

   

.. function:: setSystemInitialized()


.. function:: getSystemInitialized()


.. class:: ReadFromClientErrorSeverity

   Bases: :class:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. attribute:: NotSet
      :annotation: = 0

      

   .. attribute:: InvalidatesOther
      :annotation: = 1

      

   .. attribute:: Empty
      :annotation: = 2

      

   .. attribute:: Invalid
      :annotation: = 3

      


.. class:: ReadFromClientError

   .. attribute:: severity
      :annotation: :ReadFromClientErrorSeverity

      

   .. attribute:: errorMessage
      :annotation: :str

      

   .. attribute:: fieldPath
      :annotation: :List[str]

      

   .. attribute:: invalidatedFields
      :annotation: :List[str]

      


.. class:: UniqueLockMethod

   Bases: :class:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. attribute:: SameValue
      :annotation: = 1

      

   .. attribute:: SameSet
      :annotation: = 2

      

   .. attribute:: SameList
      :annotation: = 3

      


.. class:: UniqueValue

   .. attribute:: method
      :annotation: :UniqueLockMethod

      

   .. attribute:: lockEmpty
      :annotation: :bool

      

   .. attribute:: message
      :annotation: :str

      


.. class:: MultipleConstraints

   .. attribute:: minAmount
      :annotation: :int = 0

      

   .. attribute:: maxAmount
      :annotation: :int = 0

      

   .. attribute:: preventDuplicates
      :annotation: :bool = False

      


.. class:: baseBone(descr='', defaultValue=None, required=False, params=None, multiple=False, indexed=True, languages=None, searchable=False, vfunc=None, readOnly=False, visible=True, unique=False, isEmptyFunc=None, getEmtpyValueFunc=None, **kwargs)


   Bases: :class:`object`

   .. attribute:: hasDBField
      :annotation: = True

      

   .. attribute:: type
      :annotation: = hidden

      

   .. attribute:: isClonedInstance
      :annotation: = False

      

   .. method:: setSystemInitialized(self)

      Can be overridden to initialize properties that depend on the Skeleton system being initialized


   .. method:: isInvalid(self, value)

      Returns None if the value would be valid for
      this bone, an error-message otherwise.


   .. method:: isEmpty(self, rawValue: Any) -> bool

      Check if the given single value represents the "empty" value.
      This usually is the empty string, 0 or False.

      Warning: isEmpty takes precedence over isInvalid! The empty value is always valid - unless the bone
              is required. But even then the empty value will be reflected back to the client.

      Warning: rawValue might be the string/object received from the user (untrusted input!) or the value
              returned by get


   .. method:: getDefaultValue(self, skeletonInstance)


   .. method:: getEmptyValue(self) -> Any

      Returns the value representing an empty field for this bone.
      This might be the empty string for str/text Bones, Zero for numeric bones etc.


   .. method:: __setattr__(self, key, value)

      Implement setattr(self, name, value).


   .. method:: collectRawClientData(self, name, data, multiple, languages, collectSubfields)


   .. method:: parseSubfieldsFromClient(self) -> bool

      Whenever this request should try to parse subfields submitted from the client.
      Set only to true if you expect a list of dicts to be transmitted


   .. method:: singleValueFromClient(self, value, skel, name, origData)


   .. method:: fromClient(self, skel: SkeletonInstance, name: str, data: dict) -> Union[(None, List[ReadFromClientError])]

      Reads a value from the client.
      If this value is valid for this bone,
      store this value and return None.
      Otherwise our previous value is
      left unchanged and an error-message
      is returned.

      :param name: Our name in the skeleton
      :type name: str
      :param data: User-supplied request-data
      :type data: dict
      :returns: None or str


   .. method:: validateMultipleConstraints(self, skel: SkeletonInstance, name: str) -> List[ReadFromClientError]

      Validates our value against our multiple constrains.
      Returns a ReadFromClientError for each violation (eg. too many items and duplicates)


   .. method:: singleValueSerialize(self, value, skel: SkeletonInstance, name: str, parentIndexed: bool)


   .. method:: serialize(self, skel: SkeletonInstance, name: str, parentIndexed: bool) -> bool

      Serializes this bone into something we
      can write into the datastore.

      :param name: The property-name this bone has in its Skeleton (not the description!)
      :type name: str
      :returns: dict


   .. method:: singleValueUnserialize(self, val, skel: viur.core.skeleton.SkeletonInstance, name: str)


   .. method:: unserialize(self, skel: viur.core.skeleton.SkeletonInstance, name: str) -> bool

      Inverse of serialize. Evaluates whats
      read from the datastore and populates
      this bone accordingly.
      :param name: The property-name this bone has in its Skeleton (not the description!)
      :type name: str
      :param expando: An instance of the dictionary-like db.Entity class
      :type expando: db.Entity
      :returns: bool


   .. method:: delete(self, skel: viur.core.skeleton.SkeletonInstance, name: str)

      Like postDeletedHandler, but runs inside the transaction
      :param skel:
      :param name:
      :return:


   .. method:: buildDBFilter(self, name, skel, dbFilter, rawFilter, prefix=None)

      Parses the searchfilter a client specified in his Request into
      something understood by the datastore.
      This function must:

              * Ignore all filters not targeting this bone
              * Safely handle malformed data in rawFilter
                      (this parameter is directly controlled by the client)

      :param name: The property-name this bone has in its Skeleton (not the description!)
      :type name: str
      :param skel: The :class:`server.db.Query` this bone is part of
      :type skel: :class:`server.skeleton.Skeleton`
      :param dbFilter: The current :class:`server.db.Query` instance the filters should be applied to
      :type dbFilter: :class:`server.db.Query`
      :param rawFilter: The dictionary of filters the client wants to have applied
      :type rawFilter: dict
      :returns: The modified :class:`server.db.Query`


   .. method:: buildDBSort(self, name, skel, dbFilter, rawFilter)

      Same as buildDBFilter, but this time its not about filtering
      the results, but by sorting them.
      Again: rawFilter is controlled by the client, so you *must* expect and safely hande
      malformed data!

      :param name: The property-name this bone has in its Skeleton (not the description!)
      :type name: str
      :param skel: The :class:`server.skeleton.Skeleton` instance this bone is part of
      :type skel: :class:`server.skeleton.Skeleton`
      :param dbFilter: The current :class:`server.db.Query` instance the filters should be applied to
      :type dbFilter: :class:`server.db.Query`
      :param rawFilter: The dictionary of filters the client wants to have applied
      :type rawFilter: dict
      :returns: The modified :class:`server.db.Query`


   .. method:: _hashValueForUniquePropertyIndex(self, value: Union[(str, int)]) -> List[str]


   .. method:: getUniquePropertyIndexValues(self, skel, name: str) -> List[str]

      Returns a list of hashes for our current value(s), used to store in the uniquePropertyValue index.


   .. method:: getReferencedBlobs(self, skel, name)

      Returns the list of blob keys referenced from this bone


   .. method:: performMagic(self, valuesCache, name, isAdd)

      This function applies "magically" functionality which f.e. inserts the current Date or the current user.
      :param isAdd: Signals whereever this is an add or edit operation.
      :type isAdd: bool


   .. method:: postSavedHandler(self, skel, boneName, key)

      Can be overridden to perform further actions after the main entity has been written.

      :param boneName: Name of this bone
      :type boneName: str

      :param skel: The skeleton this bone belongs to
      :type skel: Skeleton

      :param key: The (new?) Database Key we've written to
      :type key: str

      :param dbObj: The db.Entity object written
      :type dbObj: db.Entity


   .. method:: postDeletedHandler(self, skel, boneName, key)

      Can be overridden to perform  further actions after the main entity has been deleted.

      :param skel: The skeleton this bone belongs to
      :type skel: Skeleton
      :param boneName: Name of this bone
      :type boneName: str
      :param key: The old Database Key of the entity we've deleted
      :type key: str


   .. method:: refresh(self, skel, boneName) -> None

      Refresh all values we might have cached from other entities.


   .. method:: mergeFrom(self, valuesCache, boneName, otherSkel)

      Clones the values from other into this instance


   .. method:: setBoneValue(self, skel, boneName, value, append, *args, **kwargs)

      Set our value to 'value'.
      Santy-Checks are performed; if the value is invalid, we flip our value back to its original
      (default) value and return false.

      :param valuesCache: Dictionary with the current values from the skeleton we belong to
      :type valuesCache: dict
      :param boneName: The Bone which should be modified
      :type boneName: str
      :param value: The value that should be assigned. It's type depends on the type of that bone
      :type boneName: object
      :param append: If true, the given value is appended to the values of that bone instead of
              replacing it. Only supported on bones with multiple=True
      :type append: bool
      :return: Wherever that operation succeeded or not.
      :rtype: bool


   .. method:: getSearchTags(self, skeletonInstance, name: str) -> Set[str]



