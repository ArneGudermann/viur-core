:mod:`core.modules.user`
========================

.. py:module:: core.modules.user


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   core.modules.user.userSkel
   core.modules.user.UserPassword
   core.modules.user.GoogleAccount
   core.modules.user.TimeBasedOTP
   core.modules.user.User



Functions
~~~~~~~~~

.. autoapisummary::

   core.modules.user.createNewUserIfNotExists


.. class:: userSkel

   Bases: :class:`viur.core.skeleton.Skeleton`

   .. attribute:: kindName
      :annotation: = user

      

   .. attribute:: name
      

      

   .. attribute:: password
      

      

   .. attribute:: uid
      

      

   .. attribute:: gaeadmin
      

      

   .. attribute:: access
      

      

   .. attribute:: status
      

      

   .. attribute:: lastlogin
      

      

   .. attribute:: otpid
      

      

   .. attribute:: otpkey
      

      

   .. attribute:: otptimedrift
      

      


.. class:: UserPassword(userModule, modulePath)


   Bases: :class:`object`

   .. class:: loginSkel

      Bases: :class:`viur.core.skeleton.RelSkel`

      .. attribute:: name
         

         

      .. attribute:: password
         

         


   .. class:: lostPasswordSkel

      Bases: :class:`viur.core.skeleton.RelSkel`

      .. attribute:: name
         

         

      .. attribute:: password
         

         


   .. attribute:: registrationEnabled
      :annotation: = False

      

   .. attribute:: registrationEmailVerificationRequired
      :annotation: = True

      

   .. attribute:: registrationAdminVerificationRequired
      :annotation: = True

      

   .. attribute:: verifySuccessTemplate
      :annotation: = user_verify_success

      

   .. attribute:: verifyEmailAddressMail
      :annotation: = user_verify_address

      

   .. attribute:: verifyFailedTemplate
      :annotation: = user_verify_failed

      

   .. attribute:: passwordRecoveryTemplate
      :annotation: = user_passwordrecover

      

   .. attribute:: passwordRecoveryMail
      :annotation: = user_password_recovery

      

   .. attribute:: passwordRecoveryAlreadySendTemplate
      :annotation: = user_passwordrecover_already_sent

      

   .. attribute:: passwordRecoverySuccessTemplate
      :annotation: = user_passwordrecover_success

      

   .. attribute:: passwordRecoveryInvalidTokenTemplate
      :annotation: = user_passwordrecover_invalid_token

      

   .. attribute:: passwordRecoveryInstuctionsSendTemplate
      :annotation: = user_passwordrecover_mail_sent

      

   .. method:: getAuthMethodName(*args, **kwargs)
      :classmethod:


   .. method:: login(self, name=None, password=None, skey='', *args, **kwargs)


   .. method:: pwrecover(self, authtoken=None, skey=None, *args, **kwargs)


   .. method:: verify(self, skey, *args, **kwargs)


   .. method:: canAdd(self)


   .. method:: addSkel(self)

      Prepare the add-Skel for rendering.
      Currently only calls self.userModule.addSkel() and sets skel["status"].value depening on
      self.registrationEmailVerificationRequired and self.registrationAdminVerificationRequired
      :return: server.skeleton.Skeleton


   .. method:: add(self, *args, **kwargs)

      Allows guests to register a new account if self.registrationEnabled is set to true

      .. seealso:: :func:`addSkel`, :func:`onAdded`, :func:`canAdd`

      :returns: The rendered, added object of the entry, eventually with error hints.

      :raises: :exc:`server.errors.Unauthorized`, if the current user does not have the required permissions.
      :raises: :exc:`server.errors.PreconditionFailed`, if the *skey* could not be verified.



.. class:: GoogleAccount(userModule, modulePath)


   Bases: :class:`object`

   .. attribute:: registrationEnabled
      :annotation: = False

      

   .. method:: getAuthMethodName(*args, **kwargs)
      :classmethod:


   .. method:: login(self, skey='', token='', *args, **kwargs)



.. class:: TimeBasedOTP(userModule, modulePath)


   Bases: :class:`object`

   .. class:: otpSkel

      Bases: :class:`viur.core.skeleton.RelSkel`

      .. attribute:: otptoken
         

         


   .. attribute:: windowSize
      :annotation: = 5

      

   .. attribute:: otpTemplate
      :annotation: = user_login_timebasedotp

      

   .. method:: get2FactorMethodName(*args, **kwargs)
      :classmethod:


   .. method:: canHandle(self, userKey)


   .. method:: startProcessing(self, userKey)


   .. method:: generateOtps(self, secret, timeDrift)

      Generates all valid tokens for the given secret


   .. method:: otp(self, otptoken=None, skey=None, *args, **kwargs)


   .. method:: updateTimeDrift(self, userKey, idx)

      Updates the clock-drift value.
      The value is only changed in 1/10 steps, so that a late submit by an user doesn't skew
      it out of bounds. Maximum change per call is 0.3 minutes.
      :param userKey: For which user should the update occour
      :param idx: How many steps before/behind was that token
      :return:



.. class:: User(moduleName, modulePath, *args, **kwargs)


   Bases: :class:`viur.core.prototypes.list.List`

   .. attribute:: kindName
      :annotation: = user

      

   .. attribute:: addTemplate
      :annotation: = user_add

      

   .. attribute:: addSuccessTemplate
      :annotation: = user_add_success

      

   .. attribute:: lostPasswordTemplate
      :annotation: = user_lostpassword

      

   .. attribute:: verifyEmailAddressMail
      :annotation: = user_verify_address

      

   .. attribute:: passwordRecoveryMail
      :annotation: = user_password_recovery

      

   .. attribute:: authenticationProviders
      

      

   .. attribute:: secondFactorProviders
      

      

   .. attribute:: validAuthenticationMethods
      :annotation: = [None, None, None]

      

   .. attribute:: secondFactorTimeWindow
      

      

   .. attribute:: adminInfo
      

      

   .. method:: extendAccessRights(self, skel)


   .. method:: addSkel(self)


   .. method:: editSkel(self, *args, **kwargs)


   .. method:: secondFactorProviderByClass(self, cls)


   .. method:: getCurrentUser(self, *args, **kwargs)


   .. method:: continueAuthenticationFlow(self, caller, userKey)


   .. method:: secondFactorSucceeded(self, secondFactor, userKey)


   .. method:: authenticateUser(self, userKey, **kwargs)

      Performs Log-In for the current session and the given userKey.

      This resets the current session: All fields not explicitly marked as persistent
      by conf["viur.session.persistentFieldsOnLogin"] are gone afterwards.

      :param authProvider: Which authentication-provider issued the authenticateUser request
      :type authProvider: object
      :param userKey: The (DB-)Key of the user we shall authenticate
      :type userKey: db.Key


   .. method:: logout(self, skey='', *args, **kwargs)

      Implements the logout action. It also terminates the current session (all keys not listed
      in viur.session.persistentFieldsOnLogout will be lost).


   .. method:: login(self, *args, **kwargs)


   .. method:: onLogin(self)


   .. method:: onLogout(self, usr)


   .. method:: edit(self, *args, **kwargs)


   .. method:: view(self, key, *args, **kwargs)

      Allow a special key "self" to reference always the current user


   .. method:: canView(self, skel)


   .. method:: getAuthMethods(self, *args, **kwargs)

      Inform tools like Viur-Admin which authentication to use


   .. method:: onDeleted(self, skel)

      Invalidate all sessions of that user



.. function:: createNewUserIfNotExists()

   Create a new Admin user, if the userDB is empty


