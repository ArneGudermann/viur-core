:mod:`core.skeleton`
====================

.. py:module:: core.skeleton


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   core.skeleton.MetaBaseSkel
   core.skeleton.SkeletonInstance
   core.skeleton.BaseSkeleton
   core.skeleton.MetaSkel
   core.skeleton.CustomDatabaseAdapter
   core.skeleton.ViurTagsSearchAdapter
   core.skeleton.seoKeyBone
   core.skeleton.Skeleton
   core.skeleton.RelSkel
   core.skeleton.RefSkel
   core.skeleton.SkelList
   core.skeleton.TaskUpdateSearchIndex
   core.skeleton.RebuildSearchIndex
   core.skeleton.TaskVacuumRelations



Functions
~~~~~~~~~

.. autoapisummary::

   core.skeleton.skeletonByKind
   core.skeleton.listKnownSkeletons
   core.skeleton.iterAllSkelClasses
   core.skeleton.processRemovedRelations
   core.skeleton.updateRelations
   core.skeleton.processVacuumRelationsChunk


.. data:: pytz
   

   

.. data:: __undefindedC__
   

   

.. class:: MetaBaseSkel(cls, name, bases, dct)


   Bases: :class:`type`

   This is the meta class for Skeletons.
   It is used to enforce several restrictions on bone names, etc.

   .. attribute:: _skelCache
      

      

   .. attribute:: _allSkelClasses
      

      

   .. attribute:: __reservedKeywords_
      

      


.. function:: skeletonByKind(kindName)


.. function:: listKnownSkeletons()


.. function:: iterAllSkelClasses()


.. class:: SkeletonInstance(skelCls, subSkelNames=None, fullClone=False, clonedBoneMap=None)


   .. attribute:: __slots__
      

      

   .. method:: items(self, yieldBoneValues: bool = False) -> Iterable[Tuple[str, baseBone]]


   .. method:: keys(self) -> Iterable[str]


   .. method:: values(self) -> Iterable[Any]


   .. method:: __iter__(self) -> Iterable[str]


   .. method:: __contains__(self, item)


   .. method:: __setitem__(self, key, value)


   .. method:: __getitem__(self, key)


   .. method:: __getattr__(self, item)


   .. method:: __delattr__(self, item)

      Implement delattr(self, name).


   .. method:: __setattr__(self, key, value)

      Implement setattr(self, name, value).


   .. method:: __repr__(self) -> str

      Return repr(self).


   .. method:: clone(self)


   .. method:: setEntity(self, entity: viur.core.db.Entity)


   .. method:: __deepcopy__(self, memodict)



.. class:: BaseSkeleton

   Bases: :class:`object`

   This is a container-object holding information about one database entity.

   It has to be sub-classed with individual information about the kindName of the entities
   and its specific data attributes, the so called bones.
   The Skeleton stores its bones in an :class:`OrderedDict`-Instance, so the definition order of the
   contained bones remains constant.

   :ivar key: This bone stores the current database key of this entity.            Assigning to this bones value is dangerous and does *not* affect the actual key its stored in.
   :vartype key: server.bones.baseBone

   :ivar creationdate: The date and time where this entity has been created.
   :vartype creationdate: server.bones.dateBone

   :ivar changedate: The date and time of the last change to this entity.
   :vartype changedate: server.bones.dateBone

   .. attribute:: __viurBaseSkeletonMarker__
      :annotation: = True

      

   .. attribute:: boneMap
      

      

   .. method:: subSkel(cls, *args, fullClone=False, **kwargs)
      :classmethod:

      Creates a new sub-skeleton as part of the current skeleton.

      A sub-skeleton is a copy of the original skeleton, containing only a subset of its bones.
      To define sub-skeletons, use the subSkels property of the Skeleton object.

      By passing multiple sub-skeleton names to this function, a sub-skeleton with the union of
      all bones of the specified sub-skeletons is returned.

      If an entry called "*" exists in the subSkels-dictionary, the bones listed in this entry
      will always be part of the generated sub-skeleton.

      :param name: Name of the sub-skeleton (that's the key of the subSkels dictionary);                                              Multiple names can be specified.
      :type name: str

      :return: The sub-skeleton of the specified type.
      :rtype: server.skeleton.Skeleton


   .. method:: setSystemInitialized(cls)
      :classmethod:


   .. method:: setBoneValue(cls, skelValues, boneName, value, append=False)
      :classmethod:

      Allow setting a bones value without calling fromClient or assigning to valuesCache directly.
      Santy-Checks are performed; if the value is invalid, that bone flips back to its original
      (default) value and false is returned.

      :param boneName: The Bone which should be modified
      :type boneName: str
      :param value: The value that should be assigned. It's type depends on the type of that bone
      :type value: object
      :param append: If true, the given value is appended to the values of that bone instead of
              replacing it. Only supported on bones with multiple=True
      :type append: bool
      :return: Wherever that operation succeeded or not.
      :rtype: bool


   .. method:: fromClient(cls, skelValues, data)
      :classmethod:

      Load supplied *data* into Skeleton.

      This function works similar to :func:`~server.skeleton.Skeleton.setValues`, except that
      the values retrieved from *data* are checked against the bones and their validity checks.

      Even if this function returns False, all bones are guaranteed to be in a valid state.
      The ones which have been read correctly are set to their valid values;
      Bones with invalid values are set back to a safe default (None in most cases).
      So its possible to call :func:`~server.skeleton.Skeleton.toDB` afterwards even if reading
      data with this function failed (through this might violates the assumed consistency-model).

      :param data: Dictionary from which the data is read.
      :type data: dict

      :returns: True if all data was successfully read and taken by the Skeleton's bones.                     False otherwise (eg. some required fields where missing or invalid).
      :rtype: bool


   .. method:: refresh(cls, skelValues)
      :classmethod:

      Refresh the bones current content.

      This function causes a refresh of all relational bones and their associated
      information.



.. class:: MetaSkel(cls, name, bases, dct)


   Bases: :class:`core.skeleton.MetaBaseSkel`

   This is the meta class for Skeletons.
   It is used to enforce several restrictions on bone names, etc.


.. class:: CustomDatabaseAdapter

   .. attribute:: providesFulltextSearch
      :annotation: :bool = False

      

   .. attribute:: fulltextSearchGuaranteesQueryConstrains
      :annotation: = False

      

   .. attribute:: providesCustomQueries
      :annotation: :bool = False

      

   .. method:: preprocessEntry(self, entry: viur.core.db.Entity, skel: core.skeleton.BaseSkeleton, changeList: List[str], isAdd: bool) -> viur.core.db.Entity

      Can be overridden to add or alter the data of this entry before it's written to firestore.
      Will always be called inside an transaction.
      :param entry: The entry containing the serialized data of that skeleton
      :param skel: The (complete) skeleton this skel.toDB() runs for
      :param changeList: List of boneNames that are changed by this skel.toDB() call
      :param isAdd: Is this an update or an add?
      :return: The (maybe modified) entity


   .. method:: updateEntry(self, dbObj: viur.core.db.Entity, skel: core.skeleton.BaseSkeleton, changeList: List[str], isAdd: bool) -> None

      Like `meth:preprocessEntry`, but runs after the transaction had completed.
      Changes made to dbObj will be ignored.
      :param entry: The entry containing the serialized data of that skeleton
      :param skel: The (complete) skeleton this skel.toDB() runs for
      :param changeList: List of boneNames that are changed by this skel.toDB() call
      :param isAdd: Is this an update or an add?


   .. method:: deleteEntry(self, entry: viur.core.db.Entity, skel: core.skeleton.BaseSkeleton) -> None

      Called, after an skeleton has been successfully deleted from firestore
      :param entry: The db.Entity object containing an snapshot of the data that has been deleted
      :param skel: The (complete) skeleton for which `meth:delete' had been called


   .. method:: fulltextSearch(self, queryString: str, databaseQuery: viur.core.db.Query) -> List[db.Entity]
      :abstractmethod:

      If this database supports fulltext searches, this method has to implement them.
      If it's a plain fulltext search engine, leave 'prop:fulltextSearchGuaranteesQueryConstrains' set to False,
      then the server will post-process the list of entries returned from this function and drop any entry that
      cannot be returned due to other constrains set in 'param:databaseQuery'. If you can obey *every* constrain
      set in that Query, we can skip this post-processing and save some CPU-cycles.
      :param queryString: the string as received from the user (no quotation or other safety checks applied!)
      :param databaseQuery: The query containing any constrains that returned entries must also match
      :return:



.. class:: ViurTagsSearchAdapter(minLength: int = 3)


   Bases: :class:`core.skeleton.CustomDatabaseAdapter`

   This Adapter implements the a simple fulltext search ontop of the datastore.
   On skel.toDB we collect all words from str/textBones, build all *minLength* postfixes and dump them
   into the property viurTags. When queried, we'll run a prefix-match against this property - thus returning
   entities with either a exact match or a match inside a word.

   Example:
           For the word "hello" we'll write "hello", "ello" and "llo" into viurTags.
           When queried with "hello" we'll have an exact match.
           When queried with "hel" we'll match the prefix for "hello"
           When queried with "ell" we'll prefix-match "ello"

   We'll automatically add this adapter if a skeleton has no other database adapter defined

   .. attribute:: providesFulltextSearch
      :annotation: = True

      

   .. attribute:: fulltextSearchGuaranteesQueryConstrains
      :annotation: = True

      

   .. method:: _tagsFromString(self, value: str) -> Set[str]

      Extract all words including all minLength postfixes from given string


   .. method:: preprocessEntry(self, entry: viur.core.db.Entity, skel: core.skeleton.Skeleton, changeList: List[str], isAdd: bool) -> viur.core.db.Entity

      Collect searchTags from skeleton and build viurTags


   .. method:: fulltextSearch(self, queryString: str, databaseQuery: viur.core.db.Query) -> List[db.Entity]

      Run a fulltext search



.. class:: seoKeyBone

   Bases: :class:`viur.core.bones.stringBone`

   .. method:: unserialize(self, skel: viur.core.skeleton.SkeletonInstance, name: str) -> bool



.. class:: Skeleton(*args, **kwargs)


   Bases: :class:`core.skeleton.BaseSkeleton`

   This is a container-object holding information about one database entity.

   It has to be sub-classed with individual information about the kindName of the entities
   and its specific data attributes, the so called bones.
   The Skeleton stores its bones in an :class:`OrderedDict`-Instance, so the definition order of the
   contained bones remains constant.

   :ivar key: This bone stores the current database key of this entity.            Assigning to this bones value is dangerous and does *not* affect the actual key its stored in.
   :vartype key: server.bones.baseBone

   :ivar creationdate: The date and time where this entity has been created.
   :vartype creationdate: server.bones.dateBone

   :ivar changedate: The date and time of the last change to this entity.
   :vartype changedate: server.bones.dateBone

   .. attribute:: kindName
      :annotation: :str

      

   .. attribute:: customDatabaseAdapter
      :annotation: :Union[CustomDatabaseAdapter, None]

      

   .. attribute:: subSkels
      

      

   .. attribute:: interBoneValidations
      :annotation: :List[Callable[[Skeleton], List[ReadFromClientError]]] = []

      

   .. attribute:: key
      

      

   .. attribute:: creationdate
      

      

   .. attribute:: changedate
      

      

   .. attribute:: viurCurrentSeoKeys
      

      

   .. method:: __repr__(self)

      Return repr(self).


   .. method:: all(cls, skelValues, **kwargs)
      :classmethod:

      Create a query with the current Skeletons kindName.

      :returns: A db.Query object which allows for entity filtering and sorting.
      :rtype: :class:`server.db.Query`


   .. method:: fromClient(cls, skelValues: core.skeleton.SkeletonInstance, data: Dict[(str, Union[List[str], str])]) -> bool
      :classmethod:

      This function works similar to :func:`~server.skeleton.Skeleton.setValues`, except that
              the values retrieved from *data* are checked against the bones and their validity checks.

              Even if this function returns False, all bones are guaranteed to be in a valid state.
              The ones which have been read correctly are set to their valid values;
              Bones with invalid values are set back to a safe default (None in most cases).
              So its possible to call :func:`~server.skeleton.Skeleton.toDB` afterwards even if reading
              data with this function failed (through this might violates the assumed consistency-model).

      :param data: Dictionary from which the data is read.
      :return: True, if all values have been read correctly (without errors), False otherwise


   .. method:: fromDB(cls, skelValues: core.skeleton.SkeletonInstance, key: Union[(str, db.KeyClass)]) -> bool
      :classmethod:

      Load entity with *key* from the data store into the Skeleton.

      Reads all available data of entity kind *kindName* and the key *key*
      from the data store into the Skeleton structure's bones. Any previous
      data of the bones will discard.

      To store a Skeleton object to the data store, see :func:`~server.skeleton.Skeleton.toDB`.

      :param key: A :class:`server.DB.Key`, :class:`server.DB.Query`, or string,                      from which the data shall be fetched.

      :returns: True on success; False if the given key could not be found.


   .. method:: toDB(cls, skelValues: core.skeleton.SkeletonInstance, clearUpdateTag: bool = False) -> viur.core.db.KeyClass
      :classmethod:

      Store current Skeleton entity to data store.

      Stores the current data of this instance into the database.
      If an *key* value is set to the object, this entity will ne updated;
      Otherwise an new entity will be created.

      To read a Skeleton object from the data store, see :func:`~server.skeleton.Skeleton.fromDB`.

      :param clearUpdateTag: If True, this entity won't be marked dirty;
              This avoids from being fetched by the background task updating relations.

      :returns: The datastore key of the entity.


   .. method:: preProcessBlobLocks(cls, skelValues, locks)
      :classmethod:

      Can be overridden to modify the list of blobs referenced by this skeleton


   .. method:: preProcessSerializedData(cls, skelValues, entity)
      :classmethod:

      Can be overridden to modify the :class:`server.db.Entity` before its actually
      written to the data store.


   .. method:: postSavedHandler(cls, skelValues, key, dbObj)
      :classmethod:

      Can be overridden to perform further actions after the entity has been written
      to the data store.


   .. method:: postDeletedHandler(cls, skelValues, key)
      :classmethod:

      Can be overridden to perform further actions after the entity has been deleted
      from the data store.


   .. method:: getCurrentSEOKeys(cls, skelValues) -> Union[(None, Dict[str, str])]
      :classmethod:

      Should be overridden to return a dictionary of language -> SEO-Friendly key
      this entry should be reachable under. How theses names are derived are entirely up to the application.
      If the name is already in use for this module, the server will automatically append some random string
      to make it unique.
      :return:


   .. method:: delete(cls, skelValues)
      :classmethod:

      Deletes the entity associated with the current Skeleton from the data store.



.. class:: RelSkel

   Bases: :class:`core.skeleton.BaseSkeleton`

   This is a Skeleton-like class that acts as a container for Skeletons used as a
   additional information data skeleton for
   :class:`~server.bones.extendedRelationalBone.extendedRelationalBone`.

   It needs to be sub-classed where information about the kindName and its attributes
   (bones) are specified.

   The Skeleton stores its bones in an :class:`OrderedDict`-Instance, so the definition order of the
   contained bones remains constant.

   .. method:: fromClient(cls, skelValues, data)
      :classmethod:

      Reads the data supplied by data.
      Unlike setValues, error-checking is performed.
      The values might be in a different representation than the one used in getValues/serValues.
      Even if this function returns False, all bones are guranteed to be in a valid state:
      The ones which have been read correctly contain their data; the other ones are set back to a safe default (None in most cases)
      So its possible to call save() afterwards even if reading data fromClient faild (through this might violates the assumed consitency-model!).

      :param data: Dictionary from which the data is read
      :type data: dict
      :returns: True if the data was successfully read; False otherwise (eg. some required fields where missing or invalid)


   .. method:: serialize(self, parentIndexed)


   .. method:: unserialize(self, values)

      Loads 'values' into this skeleton.

      :param values: dict with values we'll assign to our bones
      :type values: dict | db.Entry
      :return:



.. class:: RefSkel

   Bases: :class:`core.skeleton.RelSkel`

   This is a Skeleton-like class that acts as a container for Skeletons used as a
   additional information data skeleton for
   :class:`~server.bones.extendedRelationalBone.extendedRelationalBone`.

   It needs to be sub-classed where information about the kindName and its attributes
   (bones) are specified.

   The Skeleton stores its bones in an :class:`OrderedDict`-Instance, so the definition order of the
   contained bones remains constant.

   .. method:: fromSkel(cls, kindName: str, *args: List[str])
      :classmethod:

      Creates a relSkel from a skeleton-class using only the bones explicitly named
      in \*args

      :param skelCls: A class or instance of BaseSkel we'll adapt the model from
      :type skelCls: BaseSkeleton
      :param args: List of bone names we'll adapt
      :type args: list of str
      :return: A new instance of RefSkel
      :rtype: RefSkel



.. class:: SkelList(baseSkel=None)


   Bases: :class:`list`

   This class is used to hold multiple skeletons together with other, commonly used information.

   SkelLists are returned by Skel().all()...fetch()-constructs and provide additional information
   about the data base query, for fetching additional entries.

   :ivar cursor: Holds the cursor within a query.
   :vartype cursor: str

   .. attribute:: __slots__
      :annotation: = ['baseSkel', 'getCursor', 'customQueryInfo', 'renderPreparation']

      


.. function:: processRemovedRelations(removedKey, cursor=None)


.. function:: updateRelations(destID, minChangeTime, changeList, cursor=None)


.. class:: TaskUpdateSearchIndex

   Bases: :class:`viur.core.tasks.CallableTaskBase`

   This tasks loads and saves *every* entity of the given module.
   This ensures an updated searchIndex and verifies consistency of this data.

   .. attribute:: key
      :annotation: = rebuildSearchIndex

      

   .. attribute:: name
      :annotation: = Rebuild search index

      

   .. attribute:: descr
      :annotation: = This task can be called to update search indexes and relational information.

      

   .. method:: canCall(self) -> bool

      Checks wherever the current user can execute this task


   .. method:: dataSkel(self)


   .. method:: execute(self, module, *args, **kwargs)


   .. method:: _run(module: str, notify: str)
      :staticmethod:



.. class:: RebuildSearchIndex

   Bases: :class:`viur.core.tasks.QueryIter`

   .. method:: handleEntry(cls, skel: core.skeleton.SkeletonInstance, customData: Dict[(str, str)])
      :classmethod:


   .. method:: handleFinish(cls, totalCount: int, customData: Dict[(str, str)])
      :classmethod:



.. class:: TaskVacuumRelations

   Bases: :class:`viur.core.tasks.CallableTaskBase`

   Checks entries in viur-relations and verifies that the src-kind and it's relational-bone still exists.

   .. attribute:: key
      :annotation: = vacuumRelations

      

   .. attribute:: name
      :annotation: = Vacuum viur-relations (dangerous)

      

   .. attribute:: descr
      :annotation: = Drop stale inbound relations for the given kind

      

   .. method:: canCall(self)

      Checks wherever the current user can execute this task
      :returns: bool


   .. method:: dataSkel(self)


   .. method:: execute(self, module, *args, **kwargs)



.. function:: processVacuumRelationsChunk(module, cursor, allCount=0, removedCount=0, notify=None)

   Processes 100 Entries and calls the next batch


.. data:: SkeletonInstanceRef
   

   

.. data:: SkelListRef
   

   

